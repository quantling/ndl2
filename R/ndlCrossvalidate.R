#' Crossvalidation of a Naive Discriminative Learning model.
#' 
#' \code{ndlCrossvalidate} undertakes a crossvalidation of a Naive
#' Discriminative Learning model fitted using \code{ndlClassify}.
#' 
#' Crossvalidation of a Naive Discriminative Learning model.
#' 
#' @param formula An object of class \code{formula} (or one that can be coerced
#' to that class): a symbolic description of the model to be fitted. If
#' alternatively set to \code{=NA}, the \code{data} argument is expected to be
#' in the \code{ndl} internal format as generated by
#' \code{\link{ndlCuesOutcomes}}, and \code{ndlCrossvalidate} will check that
#' this is the case.
#' @param data A data frame (as in \code{ndlClassify}) containing the variables
#' in the \code{formula} specifying the model.
#' @param frequency A numeric vector (or the name of a column in the input data
#' frame) with the frequencies of the exemplars.  If absent, each exemplar is
#' assigned a frequency equal to 1.
#' @param k The number of folds, by default equal to 10.
#' @param folds A list of user-defined folds, each item on the list
#' representing a vector of indices indicating lines in the data frame to be
#' used for testing a model fitted with the rest of the data. By default
#' \code{NULL}, so that the folds are determined with random selection by the
#' function \code{ndlCrossvalidate}.
#' @param \dots Control arguments to be passed along to auxiliary functions, in
#' specific \code{\link{estimateWeights}} and/or
#' \code{\link{estimateActivations}}.
#' @return A list of the class \code{"ndlCrossvalidate"} with the following
#' components:
#' 
#' \describe{ \item{\code{call}}{The call matched by \code{ndlCrossvalidate}}
#' \item{\code{formula}}{The formula specified for \code{ndlCrossvalidate}}
#' \item{\code{fits}}{A list of individual fits resulting from
#' \code{ndlCrossvalidate}} \item{\code{k}}{The number of folds, by default
#' equal to 10} \item{\code{n.total}}{The sum frequency of data points}
#' \item{\code{n.train}}{The size of the training set}
#' \item{\code{n.test}}{The size of of the testing set} \item{\code{folds}}{A
#' list with the folds used in the crossvalidation; either selected at random
#' by \code{ndlCrossvalidate} or provided by the user.} }
#' @author Antti Arppe
#' @seealso \code{\link{summary.ndlCrossvalidate}, \link{ndlStatistics},
#' \link{ndlCuesOutcomes}, \link{cueCoding}, \link{estimateWeights},
#' \link{estimateActivations}}
#' @references
#' 
#' Baayen, R. H. and Milin, P.  and Filipovic Durdevic, D. and Hendrix, P. and
#' Marelli, M., An amorphous model for morphological processing in visual
#' comprehension based on naive discriminative learning. Psychological Review,
#' 118, 438-482.
#' 
#' Arppe, A. and Baayen, R. H. (in prep.). Statistical modeling and the
#' principles of human learning.
#' @keywords classif
#' @examples
#' 
#' data(think)
#' set.seed(314)
#' think <- think[sample(1:nrow(think),500),]
#' think.cv5 <- ndlCrossvalidate(Lexeme ~ Agent + Patient, data=think, k=5)
#' summary(think.cv5)
#' rm(think)
#' 
#' \dontrun{
#' data(think)
#' think.cv10 <- ndlCrossvalidate(Lexeme ~ Person + Number + Agent + Patient + Register,
#'    data=think, k=10)
#' summary(think.cv10)
#' }
#' \dontrun{
#' library(languageR)
#' data(finalDevoicing)
#' finDev.cv10 <- ndlCrossvalidate(Voice ~ Onset1Type + Onset2Type + VowelType *
#'    ConsonantType * Obstruent + Nsyll + Stress, data=finalDevoicing, k=10)
#' summary(finDev.cv10)
#' 
#' }
#' 
#' 
ndlCrossvalidate <- function(formula, data, frequency=NA, k=10, folds=NULL, ...)
{ call <- match.call()
  N <- NROW(data)

  if(class(formula)!="formula")
    if(is.na(formula))
      { if(!all(colnames(data) %in% c("Frequency","Cues","Outcomes")))
          stop("Data does not have proper structure with three columns: Frequency, Cues, Outcomes.\n")
      }
    else
      stop("Incorrect specification of argument 'formula'.\n")

  if(is.null(folds))
    { if(is.na(frequency[1]))
        { n.data=N
          sampling.space <- 1:N
        }
      else
        { if(is.character(frequency) & length(frequency)==1)
            { n.data <- sum(data[,frequency])
              sampling.space <- rep(1:N, times=data[,frequency])
            }
          if(is.numeric(frequency) & length(frequency)==N)
            { n.data <- sum(frequency)
              sampling.space <- rep(1:N, times=frequency)
            }
        }
      order.random <- sample(sampling.space, n.data, FALSE)
      if(n.data/k != round(n.data/k))
        order.random <- c(order.random, order.random[1:(ceiling(n.data/k)*k-n.data)])
      folds <- lapply(1:k, function(x) matrix(order.random,k,byrow=T)[x,])
    }
  else
    { k = length(folds)
      if(sd(sapply(folds, length))!=0)
        stop("Folds do not have same length")
      sum.folds = sum(sapply(folds, length))
      if(is.na(frequency[1]))
        n.data=NROW(data)
      else
        { if(is.character(frequency) & length(frequency)==1)
            n.data=sum(data[,frequency])
          if(is.numeric(frequency) & length(frequency)==N)
            n.data=sum(frequency)
        }
      if(sum.folds < floor(n.data/k)*k | sum.folds > ceiling(n.data/k)*k)
        stop("Folds together do not match size of data")
    }
  n.test = mean(sapply(folds, length))
  n.train = n.data - n.test

# One might want to finetune more exactly what happens if n.data/k is not not a natural number

options(ndlCrossvalidate.counter=1)

fits <- lapply(folds,
   function(test)
      { 
        cat(paste("[",getOption("ndlCrossvalidate.counter"),"]",sep=""))
        options(ndlCrossvalidate.counter=getOption("ndlCrossvalidate.counter")+1)

        if(class(formula)=="formula")
          cuesOutcomes.teach <- ndlCuesOutcomes(formula, data[-test,])
        else
          cuesOutcomes.teach <- data[-test,]

        weightMatrix.teach = estimateWeights(cuesOutcomes.teach, ...)

        if(class(formula)=="formula")
          cuesOutcomes.test <- ndlCuesOutcomes(formula, data[test,])
        else
          cuesOutcomes.test <- data[test,]
        activationMatrix.test = estimateActivations(cuesOutcomes.test, weightMatrix.teach, ...)$activationMatrix 

        ndl.test <- list(activationMatrix = activationMatrix.test,  weightMatrix = weightMatrix.teach, cuesOutcomes = cuesOutcomes.test)
        test.result <- ndlStatistics(ndl.test, ...)
        names(test.result)[which(names(test.result)=="n.data")]="n.test"

        return(test.result)
      })

     options(ndlCrossvalidate.counter=NULL)
     cat("\n")

result = list(call=call, formula = formula, fits = fits, k = k, n.total=n.data, n.train=n.train, n.test=n.test, folds = folds)
class(result) <- "ndlCrossvalidate"

return(result)

}

