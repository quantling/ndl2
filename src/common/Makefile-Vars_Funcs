################################################################################
# Standard settings

# To show all make commands set VERBOSE to some value or set Q=
ifndef VERBOSE
	Q := @
endif

# Directory into which the files will be installed with 'make install'
# Defaults to locations for system-wide usage use (will require root priviliges)
BINDIR     := /usr/local/bin
LIBDIR     := /usr/local/lib

INSTALL    := install
CXX        := g++

# When debugging with gdb with gcc as compiler the local variables in openmp
# regions aren't visible and hence their values can not be printed.
# If one isn't interested in the multithreaded aspect itself, the easiest
# workaround is to disable OPENMP with something like 'make NO_OPENMP=1'
ifndef NO_OPENMP
	CXXFLAGS += -fopenmp
else
	CXXFLAGS += -Wno-unknown-pragmas
endif

# For prerequisite dependency generation: generate depfile with user headers
CXXFLAGS   += -MMD
# RELEASE gets (also) set when building the release or install target
ifdef RELEASE
	CXXFLAGS += -D NDEBUG -O3
else
	CXXFLAGS += -Og -g3 -D _DEBUG -ggdb
endif


################################################################################
# Folders

COMMON_DIR   := ../common
DEBUG_DIR    := debug
RELEASE_DIR  := release
TEST_TMP_DIR := testingOut
DEP_DIR      := .deps

ifdef RELEASE
	BUILD_DIR  := $(RELEASE_DIR)
	BUILD_TYPE := release
else
	BUILD_DIR  := $(DEBUG_DIR)
	BUILD_TYPE := debug
endif


################################################################################
# Functions

# Usage:
# $(call get_output_path,paths_to_cpp_files) for $(BUILD_DIR)
# $(call get_output_path,paths_to_cpp_files,dir_path) for custom dir_path
define get_output_path
$(addprefix $(if $2,$2,$(BUILD_DIR))/,$(patsubst %.cpp,%.o,$(subst ../,,$1)))
endef


# Add make target $(BUILD_DIR)/$(target_name) which is created from the source
# files $(target_name)_SRCS. When you call this function you need to enclose
# it within an eval function, i.e. $(eval $(call add_target,target_name))
# Example: $(call add_target RESCORLA_WAGNER) adds the following make target
# $(BUILD_DIR)/$(UNIT_TESTER): $(call get_output_path,$(UNIT_TESTER_SRCS)
# 	$(CXX) $(CXXFLAGS) -o $@ $^ $(LDLIBS) $(LDFLAGS)
# Usage:
# $(call add_target,target_name)
define add_target
$(BUILD_DIR)/$($1): $(call get_output_path,$($(addsuffix _SRCS,$1)))
	$(CXX) $(CXXFLAGS) -o $(BUILD_DIR)/$($1) \
		$(call get_output_path,$($(addsuffix _SRCS,$1))) $(LDLIBS) $(LDFLAGS)\
		$(if $(filter %.so,$($1)),-shared,)


endef


# Adds make targets for the variables contained in the variable with the same
# name as the argument passed to this function. These targets are built from
# the sources listed in the corresponding variable with _SRCS as suffix.
# Only works if the variable, whose name was passed as the argument, is a
# recursively expanded variable (i.e. = was used for the variable assignment).
# Example:
#   MY_TARGETS = $(EXEC1) $(EXEC2) $(SHLIB1)
#   $(call add_targets_from_var,MY_TARGETS)
#   -> adds targets for $(EXEC1), $(EXEC2) and $(SHLIB1) which are built using
#      $(EXEC1_SRCS), $(EXEC2_SRCS) and $(SHLIB1_SRCS) respectively.
# Note: to debug this function replace eval with info (or use --print-data-base)
# Usage:
# $(call add_target_list,name_of_recursively_defined_variable)
define add_targets_from_var
$(foreach target_name, $(patsubst $$(%),%,$(value $(strip $1))), \
	$(if $($(addsuffix _SRCS,$(target_name))), \
		$(eval $(call add_target,$(target_name))), \
		$(error $(addsuffix _SRCS,$(target_name)) does not exist or is empty)))
endef


# Create prerequisite files
#   based on Tom Tromey's method:
#   http://make.mad-scientist.net/papers/advanced-auto-dependency-generation/
# Extend the depend files generated by the compiler with empty make targets for
# all headers. This solves the problem that other prerequisite generation
# approaches face when a previously necessary dependency doesn't exist anymore:
# make treats any targets don't exist anymore and have an empty rule as out of
# date and hence any other target depending on it will be updated (and if it
# exists it is considered up to date and nothing further is done with it).
# The following sed command creates such targets with empty rules for every
# dependency in the depend file.
#
# Usage:
# $(call create-prerequisite-file,file-stem)
define create-prerequisite-file
	cp $(BUILD_DIR)/$1.d $(DEP_DIR)/$1.$(BUILD_TYPE).P; \
		sed -e 's/#.*//' \
				-e 's/^[^:]*: *//' \
				-e 's/ *\\$$//' \
				-e '/^$$/ d' \
				-e 's/$$/ :/' < $(BUILD_DIR)/$1.d >> $(DEP_DIR)/$1.$(BUILD_TYPE).P; \
		$(RM) $(BUILD_DIR)/$1.d
endef

################################################################################
# Targets

# Use these pattern rules instead of built-in suffix rules
.SUFFIXES:
$(BUILD_DIR)/common/%.o: ../common/%.cpp
	$(CXX) $(CXXFLAGS) -o $@ -c $< $(INC)
	$(Q)$(call create-prerequisite-file,common/$*)

$(BUILD_DIR)/%.o: %.cpp
	$(CXX) $(CXXFLAGS) -o $@ -c $< $(INC)
	$(Q)$(call create-prerequisite-file,$*)


# vim: set noexpandtab ts=2 sw=2:
